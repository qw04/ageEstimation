# -*- coding: utf-8 -*-
"""duplicatingProject.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1AO31W4xOwzdsX788JQhFmrTFmmPcGdkI
"""

from google.colab import drive
drive.mount('/content/drive')

! pip install -q kaggle
from google.colab import files
files.upload()
! mkdir ~/.kaggle
! cp kaggle.json ~/.kaggle/
! chmod 600 ~/.kaggle/kaggle.json
import kaggle
! kaggle datasets download -d frabbisw/facial-age
! mkdir ageData1
from google.colab import output
! unzip facial-age.zip -d ageData1
! kaggle datasets download -d jangedoo/utkface-new
! mkdir ageData2
! unzip utkface-new.zip -d ageData2
! kaggle datasets download -d eshachakraborty00/all-age-face-dataset
! mkdir ageData3
! unzip all-age-face-dataset.zip -d ageData3
output.clear()

# import math
import numpy as np
import os
# import sys
# import tensorflow as tf
# from PIL import Image, features
from tqdm import tqdm
from google.colab import output
from google.colab.patches import cv2_imshow
import cv2
from tensorflow import keras, config
import random
from sklearn.model_selection import train_test_split

gpus = config.list_physical_devices('GPU')
if gpus:
  try:
    config.set_visible_devices(gpus, 'GPU')
    logical_gpus = config.list_logical_devices('GPU')
    print(len(gpus), "Physical GPUs,", len(logical_gpus), "Logical GPU")
  except RuntimeError as e:
    print(e)

from psutil import virtual_memory
ram_gb = virtual_memory().total / 1e9
print('Your runtime has {:.1f} gigabytes of available RAM\n'.format(ram_gb))

if ram_gb < 20:
  print('Not using a high-RAM runtime')
else:
  print('You are using a high-RAM runtime!')

CATEGORIES = [[1,20], [21,110]]
DATA_DIR_ONE = "/content/ageData1/face_age"
DATA_DIR_TWO = "/content/ageData2/UTKFace"
# EPOCHS = 98 #for 1-18
EPOCHS = 3 #for 1- 20
IMG_WIDTH = 200
IMG_HEIGHT = 200
NUM_CATEGORIES = len(CATEGORIES)
TEST_SIZE = 0.1
images = []
labels = []
names = []

augmentedFolder = "/content/drive/MyDrive/ComputingNea"
checkpoint_filepath = 'drive/MyDrive/checkpoint'

another_useless_array = []
for folder in tqdm(os.listdir(DATA_DIR_ONE)): #iterate through each folder 
  folder_path = os.path.join(DATA_DIR_ONE, folder) #this piece of code joins the 2 paths, DATA_DIR_ONE and folder
  if os.path.isdir(folder_path) and folder != 'face_age':
    counter = 0 # declare the value of the counter variable as 0 as 0 is the first element of the array we want to consider
    while counter < len(CATEGORIES): #for loop through iterate through the different classes of categories
      if CATEGORIES[counter][0] <= int(folder) <= CATEGORIES[counter][1]: #to check for which boundary this folder fits into
        temp = counter #if this is the one then store the value of counter in temp, as the value of temp will be the label for all the images in this folder
        break # and since we have found the boundary break out of the for loop
      counter += 1 # if this isnt the value we were looking for then increment the value of counter by 1

    for file in os.listdir(folder_path): # iterate through each separate file     
      try:
        names.append(os.path.join(folder_path, file))
        labels.append(temp)
      except Exception as e:
        another_useless_array.append(folder)
      pass

print(set(another_useless_array))
output.clear()

'''
takes in data from the UTK face dataset
'''
another_useless_array = []
for randomFile in tqdm(os.listdir(DATA_DIR_TWO)):
  folder_path = os.path.join(DATA_DIR_TWO, randomFile)
  var = randomFile[:3]
  if not var.isdigit():
    var = randomFile[:2]
    if not var.isdigit():
      var = randomFile[:1]

  counter = 0 
  while counter < len(CATEGORIES):
    if CATEGORIES[counter][0] <= int(var) <= CATEGORIES[counter][1]:
      temp = counter
      break
    counter += 1

  try:
    names.append(folder_path)
    labels.append(temp)
  except Exception as e:
    another_useless_array.append(randomFile)
    print(e)
    pass


print(set(another_useless_array))
output.clear()

images = np.asarray([names, labels])
images = images.T
images = images.tolist()
lst1 = [x for x in range(len(images)) if images[x][1] == '1']
lst0 = [x for x in range(len(images)) if images[x][1] == '0']
np.random.shuffle(lst1)
lst1 = lst1[:len(lst0)]

for i in lst0:
  lst1.append(i)

lst = np.asarray(lst1).T
namesTo = [images[x][0] for x in lst]
labelsTo = [images[x][1] for x in lst]

set(labels)

names = namesTo
labels = [int(x) for x in labelsTo]

import plotly.express as px
import pandas as pd

df = pd.DataFrame(labels)
df[0] = df[0].map({i:f'{CATEGORIES[i][0]} : {CATEGORIES[i][1]}' for i in range(len(CATEGORIES))}) #declares the labels for the age ranges for example 18-110, and 1-17 in this case
px.pie(df, names=df[0], title='Distribution of the Age Ranges') #displays the pie chart and puts in the title

def rotation(path):
  image = cv2.imread(path, cv2.IMREAD_COLOR)
  i = random.randint(-8,8)
  height, width = image.shape[:2]
  center = (width/2, height/2)
  image = cv2.warpAffine(src=image, M=cv2.getRotationMatrix2D(center=center, angle=i, scale=1) , dsize=(width, height))
  # newImage = cv2.resize(image, (IMG_WIDTH, IMG_HEIGHT), interpolation=cv2.INTER_LINEAR)
  gray_image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
  return gray_image

cv2_imshow(rotation(names[0]))

labels = keras.utils.to_categorical(labels)

def get_model():
    """
    Returns a compiled convolutional neural network model. Assume that the
    `input_shape` of the first layer is `(IMG_WIDTH, IMG_HEIGHT, 3)`.
    The output layer should have `NUM_CATEGORIES` units, one for each category.
    """
    model = keras.models.Sequential([
        keras.layers.Conv2D(32, (3, 3), activation="sigmoid", input_shape=(IMG_WIDTH, IMG_HEIGHT, 1)),
        keras.layers.AveragePooling2D(pool_size=(2, 2)),

        keras.layers.Conv2D(64, (3, 3), activation="sigmoid"),
        keras.layers.AveragePooling2D(pool_size=(2, 2)),

        keras.layers.Conv2D(128, (3, 3), activation="sigmoid"),
        keras.layers.AveragePooling2D(pool_size=(2, 2)),

        keras.layers.Conv2D(256, (3, 3), activation="sigmoid"),
        keras.layers.AveragePooling2D(pool_size=(2, 2)),

        keras.layers.GlobalAveragePooling2D(),
        keras.layers.Flatten(),

        keras.layers.Dense(NUM_CATEGORIES * 32, activation="sigmoid"),
        keras.layers.Dense(NUM_CATEGORIES, activation="softmax")
    ])
    return model

model = get_model()
model.summary()

# model = keras.models.load_model(checkpoint_filepath)

def func(model, names, labels):
  x_train, x_test, y_train, y_test = train_test_split(
      np.array(names), np.array(labels), test_size=TEST_SIZE
  )

  x_train = np.asarray([rotation(name) for name in x_train])
  x_test = np.asarray([rotation(name) for name in x_test])

  model_checkpoint_callback = keras.callbacks.ModelCheckpoint(filepath=checkpoint_filepath)
  model.fit(x_train,
            np.asarray(y_train),
            epochs = 2,
            validation_data=(x_test, np.asarray(y_test)),
            # callbacks=[model_checkpoint_callback], 
            verbose = 0
            )

# anotherPath = "/content/drive/MyDrive/someImage.JPG"
data_dir3 = "/content/ageData3/All-Age-Faces Dataset/original images"
CATEGORIES = [[1,17],[18,110]]
namesTest = []
labelsTest = []
useless_array = []
for randomFile in tqdm(os.listdir(data_dir3)):
  folder_path = os.path.join(data_dir3, randomFile)
  counter = 0
  while counter < len(CATEGORIES):
    if CATEGORIES[counter][0] <= int(randomFile[-6:-4]) <= CATEGORIES[counter][1]:
      temp = counter
      break
    counter += 1
  try:
    namesTest.append(folder_path)
    labelsTest.append(temp)
  except Exception as e:
    useless_array.append(randomFile)
    pass

print(set(useless_array))
# output.clear()

def read(path):
  image = cv2.imread(path, cv2.IMREAD_COLOR)
  newImage = cv2.resize(image, (IMG_WIDTH, IMG_HEIGHT), interpolation=cv2.INTER_LINEAR)
  gray_image = cv2.cvtColor(newImage, cv2.COLOR_BGR2GRAY)
  return gray_image

imagesTest = np.asarray([read(name) for name in tqdm(namesTest)])
labelsTest = keras.utils.to_categorical(labelsTest)

def evaluate(model, imagesTest, labelsTest):
  a = model.evaluate(imagesTest, np.asarray(labelsTest), verbose = 0)
  return a

# optimizer = keras.optimizers.Nadam(learning_rate=0.001, beta_1=0.9, beta_2=0.999, epsilon=1e-07, name='Nadam')
optimizer = keras.optimizers.Adamax(learning_rate=0.001, beta_1=0.9, beta_2=0.999, epsilon=1e-07, name='Adamax') #this is the one
# optimizer = keras.optimizers.SGD(learning_rate=0.01, momentum=0.0, nesterov=False, name='SGD')
# optimizer = keras.optimizers.Adadelta(learning_rate=0.001, rho=0.95, epsilon=1e-07, name='Adadelta')

model.compile(
        optimizer=optimizer,
        loss="categorical_crossentropy",
        metrics=["binary_accuracy"],
    )

array = []
for e in tqdm(range(EPOCHS)):
  func(model, names, labels)

evaluate(model, imagesTest, labelsTest)

model.save(checkpoint_filepath)

model = keras.models.load_model(checkpoint_filepath)

array = np.asarray(array).T

import matplotlib.pyplot as plt
plt.plot(array[0], array[1])
plt.show()

array = np.asarray(array).T

# array[:5]
newArray = [array[i][1] for i in range(len(array))]

max(newArray)

newArray.index(max(newArray[3:]))

